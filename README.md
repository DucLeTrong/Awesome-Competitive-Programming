# Awesome Competitive Programming Problems

This repository contains my implementation of useful data structures, algorithms and solutions for some **awesome** competitive programming problems in Hackerrank

I create this for faster implementation in interviews and programming contests

Written in Python 3

How to use
----------
- [x] : Useful data structures or algorithms

- : Solutions for some awesome competitive programming problems

**Mathematics** : Type of the Algorithm

**Permutation Problems** : Category of the Problem

[Lexicographic Permutations](https://github.com/leduckhai/Awesome-Competitive-Programming/blob/main/Mathematics/Lexicographic_Permutations.ipynb) : Name of the problem

```
Awesome-Competitive-Programming 
│   README.md 
│
└───Folder 1        : Type of Algorithm 
│   │   File1.ipynb : Python codes for the problem
│   │   File1.pdf   : Descriptions and solution guides for the problem
│   │   ...   
│   
└───Folder 2
│   │   File2.ipynb
│   │   File2.pdf
│   │   ...
│
└───...    
```

Algorithms
----------
### Binary Search Tree Algorithm
#### Binary Search Tree Algorithm Applications
1. [Prime Permutations](https://github.com/leduckhai/Awesome-Competitive-Programming/blob/main/Binary%20Search%20Tree%20Algorithm/Prime_Permutations.ipynb)
- [x] Find a Number of a Sorted List - **O(logn)**
- [x] Find the Index of a Number in a Sorted List - **O(logn)**

### Searching and Graph Algorithms
1. [Lily's Homework](https://github.com/leduckhai/Awesome-Competitive-Programming/blob/main/Searching%20and%20Graph%20Algorithms/Lily's_Homework.ipynb)
- [x] Graph Representation using Adjacency List
- [x] Unweighted Graph
- [x] Breadth-First Search Shortest Path - **O(V+E)**

2. [Count Luck](https://github.com/leduckhai/Awesome-Competitive-Programming/blob/main/Searching%20and%20Graph%20Algorithms/Count_Luck.ipynb)
- [x] Graph Representation using Adjacency List
- [x] Unweighted Graph (also for disconnected graph)
- [x] Breadth-First Search Shortest Path - **O(V+E)**

3. [Count Luck 2](https://github.com/leduckhai/Awesome-Competitive-Programming/blob/main/Searching%20and%20Graph%20Algorithms/Count_Luck_2.ipynb)
- [x] Graph Representation using Adjacency Matrix
- [x] Un- and weighted Graph
- [x] Dijkstra Shortest Path (also for disconnected graph) - **O(E.log V)**

4. [KnightL on a Chessboard](https://github.com/leduckhai/Awesome-Competitive-Programming/blob/main/Searching%20and%20Graph%20Algorithms/KnightL_on_a_Chessboard.ipynb)
- [x] Graph Representation using Adjacency List
- [x] Unweighted Graph (also for disconnected graph)
- [x] Breadth-First Search Shortest Path - **O(V+E)**

5. [Connected Cells in a Grid](https://github.com/leduckhai/Awesome-Competitive-Programming/blob/main/Searching%20and%20Graph%20Algorithms/Connected_Cells_in_a_Grid.ipynb)
- [x] Graph Representation using Adjacency List
- [x] Unweighted Graph (also for disconnected graph)
- [x] Connected Components
- [x] Breadth-First Search - **O(V+E) for Adjacency List**

6. [Red Knight's Shortest Path](https://github.com/leduckhai/Awesome-Competitive-Programming/blob/main/Searching%20and%20Graph%20Algorithms/Red_Knight's_Shortest_Path.ipynb)
- [x] Graph Representation using Adjacency List 
- [x] Find all nodes in graph - **O(VE) for Adjacency List**
- [x] Find all paths between 2 nodes using Breadth-First Search - **NP-Hard**

### Greedy Algorithm
1. [Sherlock and The Beast](https://github.com/leduckhai/Awesome-Competitive-Programming/blob/main/Greedy%20Algorithm/Sherlock_and_The_Beast.ipynb)
- Find the "Decent Number" having n Digits ("Decent Number" has its digits to be only 3's and/or 5's; the number of 3's it contains is divisible by 5; the number of 5's it contains is divisible by 3; and it is the largest such number for its length)

2. [Largest Permutation](https://github.com/leduckhai/Awesome-Competitive-Programming/blob/main/Greedy%20Algorithm/Largest_Permutation.ipynb)
- Swap 2 digits of a number k times to get largest number - **O(n)**

### Dynamic Programming
#### Coin Change Algorithms
1. [The Coin Change Problem](https://github.com/leduckhai/Awesome-Competitive-Programming/blob/main/Dynamic%20Programming/The_Coin_Change_Problem.ipynb)
- [x] How many ways to pay V money using C coins [C1,C2,...Cn] - **O(C.V)**

#### Subarray/Subsequence Problems
2. [The Maximum Subarray](https://github.com/leduckhai/Awesome-Competitive-Programming/blob/main/Dynamic%20Programming/The_Maximum_Subarray.ipynb)
- [x] Contiguous Subarray/Kadane's Algorithm: Find the largest sum of any contiguous subarray - **O(n)**

3. [Common Child](https://github.com/leduckhai/Awesome-Competitive-Programming/blob/main/Dynamic%20Programming/Common_Child.ipynb)
- [x] Longest Common Subsequence Algorithm: Find the length of longest string S, S is child of S1 and S2 - **O(|S1|.|S2|)**

#### Non-categorized
4. [Maximum Path Sum](https://github.com/leduckhai/Awesome-Competitive-Programming/blob/main/Dynamic%20Programming/Maximum_Path_Sum.ipynb)
- Find Maximum Sum from Top to Bottom of Triangular Array

### Mathematics
#### Binomial Coefficient Problems
1. - [x] [Pascal Triangle](https://github.com/leduckhai/Awesome-Competitive-Programming/blob/main/Mathematics/Pascal_Triangle.ipynb): Create Pascal Triangle (to Calculate Multiple Large-Number Combinations) - **O(n<sup>2</sup>)**

2.- [Lattice Paths](https://github.com/leduckhai/Awesome-Competitive-Programming/blob/main/Mathematics/Lattice_Paths.ipynb)[[PDF]](https://github.com/leduckhai/Awesome-Competitive-Programming/blob/main/Mathematics/Lattice_Paths.pdf): Find the number of routes from the top left corner to the bottom right corner in a rectangular grid

#### Factors Problems
3. [Largest Palindrome Product](https://github.com/leduckhai/Awesome-Competitive-Programming/blob/main/Mathematics/Largest_Palindrome_Product.ipynb)
- [x] Find All Factors of a Number - **O(n<sup>1/2</sup>)**

#### Multiples Problems
4. [Multiples of 3 and 5](https://github.com/leduckhai/Awesome-Competitive-Programming/blob/main/Mathematics/Multiples_of_3_and_5.ipynb)
- [x] Find Sum of Multiples of a Number - **O(1)**

5. [Smallest Multiple](https://github.com/leduckhai/Awesome-Competitive-Programming/blob/main/Mathematics/Smallest_Multiple.ipynb)
- [x] Find Least Common Multiple of Multiple Numbers

#### Permutation Problems
6. [Lexicographic Permutations](https://github.com/leduckhai/Awesome-Competitive-Programming/blob/main/Mathematics/Lexicographic_Permutations.ipynb)
- [x] Find n-th Lexicographic Permutation of a very long Word - **O(n)**

7. [Permuted Multiples](https://github.com/leduckhai/Awesome-Competitive-Programming/blob/main/Mathematics/Permuted_Multiples.ipynb)
- [x] Check if 2 Numbers are Permutations - **O(n)** , n = max(|Sn1|,|Sn2|,10)

#### Primes Problems
8. [Circular Primes](https://github.com/leduckhai/Awesome-Competitive-Programming/blob/main/Mathematics/Circular_Primes.ipynb)
- [x] "Sieve Method" Primes: Find All Primes < n - **O(n<sup>1/2</sup>)**
- [x] Common Primality Test: Check if n is a Prime Number using "Common Method" - **O(n<sup>1/2</sup>)**

9. [Spiral Primes](https://github.com/leduckhai/Awesome-Competitive-Programming/blob/main/Mathematics/Spiral_Primes.ipynb)
- [x] Miller-Rabin Primality Test: Check if n is a Prime Number using Probabilistic Test - **O(k.log<sup>3</sup>n)** , k = \[1,2,...]

10. [Totient Maximum](https://github.com/leduckhai/Awesome-Competitive-Programming/blob/main/Mathematics/Totient_Maximum.ipynb)
- [x] Euler Totient Function: Find the Number of Coprimes less than n - **O(n.loglogn + logn + k)** , k is the number of prime factors of n **sai; cần chỉnh thành 2 ver. tiotient query và single**
- [x] Coprimes Check: Check if 2 Numbers are Coprime - **O(log a.b)**

#### Primes-Factors Problems
11. - [x] [Euler Totient Function (Number List)](https://github.com/leduckhai/Awesome-Competitive-Programming/blob/main/Mathematics/Euler_Totient_NumList.ipynb): Find ALL Numbers of Coprimes < n based on Euler Totient Function - **O((l) + m.loglogm + l.(logm + k))** , k is the number of prime factors of n; m and l is max value and length of the input number list
      
12. - [x] [Euler Totient Function (Single Number)](https://github.com/leduckhai/Awesome-Competitive-Programming/blob/main/Mathematics/Euler_Totient_SingleNum.ipynb): Find the Number of Coprimes < n based on Euler Totient Function - **O(n<sup>1/2</sup> + k)** , k is the number of prime factors of the input number n

13. - [x] ["Sieve Method" Smallest Prime Factors (SPF)](https://github.com/leduckhai/Awesome-Competitive-Programming/blob/main/Mathematics/Sieve_SPF.ipynb): Find Smallest Prime Factors for All Numbers < N - **O(n.loglogn)** 
 
14. - [x] [Prime Factorization using Smallest Prime Factor](https://github.com/leduckhai/Awesome-Competitive-Programming/blob/main/Mathematics/PrimeFactorization_SPF.ipynb): Find All Prime Factors of a Number using Smallest Prime Factor (SPF) - **O(log n)** if a list of all Smallest Prime Factors from 0 to n available

15. - [x] [Prime Factorization](https://github.com/leduckhai/Awesome-Competitive-Programming/blob/main/Mathematics/PrimeFactorization.ipynb): Find All Prime Factors of a Number - **O(n<sup>1/2</sup>)**

#### Non-categorized
12. [Number Spiral Diagonals](https://github.com/leduckhai/Awesome-Competitive-Programming/blob/main/Mathematics/Number_Spiral_Diagonals.ipynb)
- Find Sum of Diagonals of Ulam Spiral Matrix

### Recursion


